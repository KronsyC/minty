"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.kDefaultPropertyForFromRoot = exports.kInheritedRawPropertyStore = void 0;
const kIsRoot = Symbol("Is Root?");
const kChildren = Symbol("Children");
const kParent = Symbol("Parent");
exports.kInheritedRawPropertyStore = Symbol("Inherited Raw Property Store");
exports.kDefaultPropertyForFromRoot = Symbol("Default Property for FromRoot Decorator");
class Nestable {
    constructor() {
        this[_a] = [];
        this[_b] = {};
        this[_c] = {};
        this[kIsRoot] = true;
    }
    addChild(child) {
        if (child === this) {
            throw new Error("Nestable cannot be it's own child");
        }
        if (!child[kParent]) {
            child[kParent] = this;
            child[kIsRoot] = false;
        }
        this[kChildren].push(child);
    }
    getChildren() {
        return this[kChildren];
    }
    deepGetChildren() {
        const children = [];
        this.getChildren().forEach(child => {
            children.push(child);
            children.push(...child.deepGetChildren());
        });
        return children;
    }
    getRootNode() {
        if (this[kIsRoot]) {
            return this;
        }
        else if (this[kParent]) {
            return this[kParent].getRootNode();
        }
        else {
            throw new Error("Cannot Get Root Node For Nestable");
        }
    }
    getParent() {
        if (this[kParent]) {
            return this[kParent];
        }
        else {
            return undefined;
        }
    }
}
exports.default = Nestable;
_a = kChildren, _b = exports.kInheritedRawPropertyStore, _c = exports.kDefaultPropertyForFromRoot;
