import { AnySchema, AnySchemaTemplate, ArraySchema, ArraySchemaTemplate, BooleanSchema, BooleanSchemaTemplate, NumberSchema, NumberSchemaTemplate, ObjectSchema, ObjectSchemaTemplate, StringSchema, StringSchemaTemplate } from "./Schemas";
import Validator, { ValidatorOptions } from "./lib/Validator/Validator";
import Encoder, { BuildEncoderOptions } from "./lib/Encoder/Encoder";
import { GenericSchema as Schema, GenericSchemaTemplate as SchemaTemplate, Parser } from ".";
import Normalizer from "./lib/Normalizer/Normalizer";
declare const kValidator: unique symbol;
declare const kParser: unique symbol;
declare const kEncoder: unique symbol;
declare const kNormalizer: unique symbol;
declare const kSchemaRefStore: unique symbol;
export interface SchematicaOptions {
}
export interface SchematicaError {
    type: string;
    context: string;
    reason: string;
}
declare type EncoderFn<InputType> = {
    error?: SchematicaError;
    (data: InputType): string;
};
declare type ValidatorFn<InputType> = {
    error?: SchematicaError;
    (data: InputType): boolean;
};
export default class Schematica {
    [kSchemaRefStore]: Map<string, Schema>;
    [kValidator]: Validator;
    [kEncoder]: Encoder;
    [kParser]: Parser;
    [kNormalizer]: Normalizer;
    constructor(options?: SchematicaOptions);
    getSchema(ref: string): Schema;
    buildValidator(schema: AnySchema, options?: ValidatorOptions): ValidatorFn<any>;
    buildValidator(schema: BooleanSchema, options?: ValidatorOptions): ValidatorFn<boolean>;
    buildValidator(schema: NumberSchema, options?: ValidatorOptions): ValidatorFn<number>;
    buildValidator(schema: ObjectSchema, options?: ValidatorOptions): ValidatorFn<object>;
    buildValidator(schema: StringSchema, options?: ValidatorOptions): ValidatorFn<string>;
    buildValidator(schema: ArraySchema, options?: ValidatorOptions): ValidatorFn<any[]>;
    buildValidator(schema: Schema, options?: ValidatorOptions): ValidatorFn<unknown>;
    buildSerializer(schema: AnySchema, options?: BuildEncoderOptions): EncoderFn<any>;
    buildSerializer(schema: BooleanSchema, options?: BuildEncoderOptions): EncoderFn<boolean>;
    buildSerializer(schema: NumberSchema, options?: BuildEncoderOptions): EncoderFn<number>;
    buildSerializer(schema: ObjectSchema, options?: BuildEncoderOptions): EncoderFn<object>;
    buildSerializer(schema: StringSchema, options?: BuildEncoderOptions): EncoderFn<string>;
    buildSerializer(schema: ArraySchema, options?: BuildEncoderOptions): EncoderFn<any[]>;
    buildSerializer(schema: Schema, options?: BuildEncoderOptions): EncoderFn<unknown>;
    buildNormalizer(schema: AnySchema): (data: any) => any;
    buildNormalizer(schema: BooleanSchema): (data: any) => boolean;
    buildNormalizer(schema: NumberSchema): (data: any) => number;
    buildNormalizer(schema: ObjectSchema): (data: object) => object;
    buildNormalizer(schema: StringSchema): (data: any) => string;
    buildNormalizer(schema: ArraySchema): (data: any[]) => any[];
    buildNormalizer(schema: Schema): (data: any) => any;
    createSchema(schema: AnySchemaTemplate): AnySchema;
    createSchema(schema: BooleanSchemaTemplate): BooleanSchema;
    createSchema(schema: ObjectSchemaTemplate): ObjectSchema;
    createSchema(schema: NumberSchemaTemplate): NumberSchema;
    createSchema(schema: StringSchemaTemplate): StringSchema;
    createSchema(schema: ArraySchemaTemplate): ArraySchema;
    createSchema(schema: SchemaTemplate): Schema;
    buildParser(schema: Schema): any;
}
export {};
