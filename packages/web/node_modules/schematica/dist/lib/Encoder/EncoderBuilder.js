"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.codeGenDeps = void 0;
var __1 = require("../..");
var getValidator_1 = __importDefault(require("../Validator/getValidator"));
exports.codeGenDeps = "\nfunction $escaped(char){\n    switch(char){\n        case '\"':\n            return '\\\"'\n        case \"\\b\":\n            return \"\\b\"\n        case \"\\\\\":\n            return \"\\\\\\\\\"\n        case \"\\f\":\n            return \"\\\\f\"\n        case \"\\n\":\n            return \"\\\\n\"\n        case \"\\r\":\n            return \"\\\\r\"\n        default:\n            throw new Error(`Could not find escaped version for character ${char}`)\n    }\n}\nfunction $encodeStr(string){\n    let data = string\n    let i=data.length-1;\n    while(i>-1){\n        const char = data[i]   \n        if(char==='\"'|| char===\"\\b\" || char===\"\\\\\" || char===\"\\f\" || char===\"\\n\" || char===\"\\r\" ){                        \n            data = data.slice(0, i) + $escaped(char) + data.slice(i+1)\n            i--   \n        }\n        i--\n    }\n    return '\"' + data + '\"'\n}\n";
var EncoderBuilder = (function () {
    function EncoderBuilder(validator) {
        this.validator = validator;
    }
    EncoderBuilder.prototype.buildStringEncoder = function (schema) {
        return "\n        return $encodeStr(".concat(schema.id, ")\n        ");
    };
    EncoderBuilder.prototype.buildNumberEncoder = function (schema) {
        return "\n            const num = Number(".concat(schema.id, ")\n            return ''+num\n        ");
    };
    EncoderBuilder.prototype.buildBooleanEncoder = function (schema) {
        return "\n            return ".concat(schema.id, " ? \"true\" : \"false\"\n        ");
    };
    EncoderBuilder.prototype.buildObjectEncoder = function (schema) {
        var propertyEncoders = function () {
            var e_1, _a;
            var code = "";
            var first = true;
            try {
                for (var _b = __values(schema.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), name = _d[0], sch = _d[1];
                    var encode = "\n                encoded+=`".concat(first ? "" : ",", "\"").concat(name, "\":${encode_").concat(sch.id, "(").concat(schema.id, "[\"").concat(name, "\"])}`\n                ");
                    if (schema.required.includes(name)) {
                        code += "\n                    ".concat(encode, "\n                    ");
                    }
                    else {
                        code += "\n                    if(".concat(schema.id, "[\"").concat(name, "\"]){\n                        ").concat(encode, "\n                    }\n                    ");
                    }
                    first = false;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return code;
        };
        function isPropertyCheck(v) {
            var e_2, _a;
            var code = "";
            var first = true;
            try {
                for (var _b = __values(schema.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), key = _d[0], _ = _d[1];
                    if (!first) {
                        code += "||";
                    }
                    code += " ".concat(v, "===\"").concat(key, "\"");
                    first = false;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return code;
        }
        function unknownPropertyEncoders() {
            var code = "\n            Object.keys(".concat(schema.id, ").forEach(key=> {\n                if(!(").concat(isPropertyCheck("key"), ")){\n                    encoded+=\",\"+'\"'+key+'\"'+\":\"+JSON.stringify(").concat(schema.id, "[key])\n                }\n            })\n            ");
            return code;
        }
        return "\n            let encoded=\"{\";\n            ".concat(propertyEncoders(), "\n            ").concat(!schema.strict ? unknownPropertyEncoders() : "", "\n            encoded+=\"}\";\n            return encoded;\n        ");
    };
    EncoderBuilder.prototype.buildArrayEncoder = function (schema) {
        var childEncoders = function () {
            var e_3, _a;
            var code = "";
            try {
                for (var _b = __values(schema.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sch = _c.value;
                    code += "\n                if(!enc && ".concat(sch.typecheck.replaceAll(sch.id, "item"), "){\n                    const ").concat(sch.id, "_encoded = encode_").concat(sch.id, "(item);\n                    enc=true;\n                    encoded+= !first?\",\"+").concat(sch.id, "_encoded : ").concat(sch.id, "_encoded\n                    first=false\n                    return\n                }\n                ");
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return code;
        };
        var fn = "\n            let encoded = \"[\";\n            let first=true;\n            ".concat(schema.id, ".forEach((item, index) => {\n                let enc=false\n                ").concat(childEncoders(), "\n                throw new Error(`Could not encode index ${index} for an unknown reason`)\n            })\n            return encoded + \"]\"\n        ");
        return fn;
    };
    EncoderBuilder.prototype.buildAnyEncoder = function (schema) {
        return "\n            return JSON.stringify(".concat(schema.id, ")\n        ");
    };
    EncoderBuilder.prototype.getEncoderSource = function (schema) {
        switch (schema.type) {
            case "string":
                return this.buildStringEncoder(schema);
            case "number":
                return this.buildNumberEncoder(schema);
            case "boolean":
                return this.buildBooleanEncoder(schema);
            case "object":
                return this.buildObjectEncoder(schema);
            case "array":
                return this.buildArrayEncoder(schema);
            case "any":
                return this.buildAnyEncoder(schema);
            default:
                throw new Error("No encoder support for type ".concat(schema.type));
        }
    };
    EncoderBuilder.prototype.buildDependencies = function (schema) {
        var validator = (0, getValidator_1.default)(schema, this.validator.builder);
        var dependencies = exports.codeGenDeps;
        dependencies += "\n        function validate_".concat(schema.id, "(").concat(schema.id, "){\n            ").concat(validator, "\n        }\n        ");
        if (schema instanceof __1.ObjectSchema || schema instanceof __1.ArraySchema) {
            for (var path in schema.allChildren) {
                var value = schema.allChildren[path];
                var source = this.build(value, { asFunction: false, child: true });
                var func = "\n                function encode_".concat(value.id, "(").concat(value.id, "){\n                    ").concat(source, "\n                }\n                ");
                dependencies += func;
            }
        }
        return dependencies;
    };
    EncoderBuilder.prototype.build = function (schema, opts) {
        var _a, _b;
        if (opts === void 0) { opts = {}; }
        var child = (_a = opts.child) !== null && _a !== void 0 ? _a : false;
        var errors = (_b = opts.additionalPropertyErrors) !== null && _b !== void 0 ? _b : true;
        var encoder = "\n        ".concat(child ? "" : "if(!validate_".concat(schema.id, "(").concat(schema.id, ")){\n            encode_").concat(schema.id, ".error = validate_").concat(schema.id, ".error\n            return null\n        }"), "\n        ");
        if (!errors) {
            encoder = "\n            if( !validate_".concat(schema.id, "( ").concat(schema.id, " ))  {\n                const error = validate_").concat(schema.id, ".error\n                if( error.type !== \"ERR_UNEXPECTED_PROPERTY\" ){\n                    encode_").concat(schema.id, ".error = validate_").concat(schema.id, ".error\n                    return null\n                }\n            }\n            ");
        }
        encoder += this.getEncoderSource(schema);
        if (!child) {
            encoder += this.buildDependencies(schema);
        }
        var asFunction = opts.asFunction === false ? false : true;
        if (asFunction) {
            encoder = new Function("\n            let encode_".concat(schema.id, " = function(").concat(schema.id, "){\n                ").concat(encoder, "\n\n            }\n            encode_").concat(schema.id, " = encode_").concat(schema.id, ".bind(encode_").concat(schema.id, ")\n            return encode_").concat(schema.id, "\n            "));
            encoder = encoder();
            Object.defineProperty(encoder, "error", { value: undefined, writable: true, configurable: true });
        }
        return encoder;
    };
    return EncoderBuilder;
}());
exports.default = EncoderBuilder;
