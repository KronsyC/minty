"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.codeGenDeps = void 0;
var getValidator_1 = __importDefault(require("../helpers/getValidator"));
var objectEncoder_1 = __importDefault(require("./objectEncoder"));
var extractSourceFromFn_1 = __importDefault(require("../helpers/extractSourceFromFn"));
exports.codeGenDeps = "\nfunction $escaped(char){\n    switch(char){\n        case '\"':\n            return '\\\"'\n        case \"\\b\":\n            return \"\\b\"\n        case \"\\\\\":\n            return \"\\\\\\\\\"\n        case \"\\f\":\n            return \"\\\\f\"\n        case \"\\n\":\n            return \"\\\\n\"\n        case \"\\r\":\n            return \"\\\\r\"\n        default:\n            throw new Error(`Could not find escaped version for character ${char}`)\n    }\n}\nfunction $encodeStr(_data){\n    try{\n        let data = _data\n        let i=data.length-1;\n        while(i>-1){\n            const char = data[i]   \n            if(char==='\"'|| char===\"\\b\" || char===\"\\\\\" || char===\"\\f\" || char===\"\\n\" || char===\"\\r\" ){                        \n                data = data.slice(0, i) + $escaped(char) + data.slice(i+1)\n                i--   \n            }\n            i--\n        }\n        return '\"' + data + '\"'\n    }\n    catch(err){\n        throw err\n    }\n}\n";
var EncoderBuilder = (function () {
    function EncoderBuilder(validator) {
        this.validator = validator;
    }
    EncoderBuilder.prototype.buildStringEncoder = function (schema, isChild) {
        if (isChild === void 0) { isChild = false; }
        var validator = (0, getValidator_1.default)(schema, this.validator.builder);
        if (isChild) {
            return new Function(schema.id, "return $encodeStr(".concat(schema.id, ")"));
        }
        return new Function(schema.id, "\n        ".concat(!isChild ? exports.codeGenDeps : "", "\n        try{\n            let data = ").concat(schema.id, "\n            ").concat(!isChild ? (0, extractSourceFromFn_1.default)(validator).replace("return true", "") : "", "\n            let i=data.length-1;\n            while(i>-1){\n                const char = data[i]   \n                if(char==='\"'|| char===\"\\b\" || char===\"\\\\\" || char===\"\\f\" || char===\"\\n\" || char===\"\\r\" ){                        \n                    data = data.slice(0, i) + $escaped(char) + data.slice(i+1)\n                    i--   \n                }\n                i--\n            }\n            return '\"' + data + '\"'\n        }\n        catch(err){\n            throw err\n        }\n        "));
    };
    EncoderBuilder.prototype.buildNumberEncoder = function (schema, isChild) {
        if (isChild === void 0) { isChild = false; }
        var validator = (0, getValidator_1.default)(schema, this.validator.builder);
        return new Function(schema.id, "\n            ".concat(!isChild ? (0, extractSourceFromFn_1.default)(validator).replace("return true", "") : "", "\n            const num = Number(").concat(schema.id, ")\n            return ''+num\n        "));
    };
    EncoderBuilder.prototype.buildBooleanEncoder = function (schema, isChild) {
        if (isChild === void 0) { isChild = false; }
        var validator = (0, getValidator_1.default)(schema, this.validator.builder);
        return new Function(schema.id, "\n            ".concat(!isChild ? (0, extractSourceFromFn_1.default)(validator).replaceAll("return true", "") : "", "\n            return ").concat(schema.id, " ? \"true\" : \"false\"\n        "));
    };
    EncoderBuilder.prototype.buildObjectEncoder = function (schema, isChild) {
        if (isChild === void 0) { isChild = false; }
        return (0, objectEncoder_1.default)(schema, this.validator.builder, this, isChild);
    };
    EncoderBuilder.prototype.buildArrayEncoder = function (schema, isChild) {
        var _this = this;
        if (isChild === void 0) { isChild = false; }
        var validator = (0, getValidator_1.default)(schema, this.validator.builder);
        var validatorSrc = (0, extractSourceFromFn_1.default)(validator);
        var childEncoderDeclarations = function () {
            var e_1, _a;
            var code = "";
            try {
                for (var _b = __values(schema.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sch = _c.value;
                    var encoder = _this.buildEncoder(sch, true);
                    var encoderSrc = (0, extractSourceFromFn_1.default)(encoder);
                    code += "\n                function ".concat(sch.id, "_encoder(").concat(sch.id, "){\n                    ").concat(encoderSrc.replaceAll("//#return", ""), "\n                }\n                ");
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return code;
        };
        var childEncoders = function () {
            var e_2, _a;
            var code = "";
            try {
                for (var _b = __values(schema.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sch = _c.value;
                    code += "\n                if(!enc&&".concat(sch.typecheck.replaceAll(sch.id, "item"), "){\n                    const ").concat(sch.id, "_encoded = ").concat(sch.id, "_encoder(item);\n                    enc=true;\n                    encoded+= !first?\",\"+").concat(sch.id, "_encoded : ").concat(sch.id, "_encoded\n                    first=false\n                    return\n                }\n                ");
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return code;
        };
        var fn = new Function(schema.id, "\n            ".concat(exports.codeGenDeps, "\n            ").concat(!isChild ? validatorSrc.slice(0, validatorSrc.indexOf("//#return") || -1) : "", "\n            ").concat(childEncoderDeclarations(), "\n            let encoded = \"[\";\n            let first=true;\n            ").concat(schema.id, ".forEach((item, index) => {\n                let enc=false\n                ").concat(childEncoders(), "\n                throw new Error(`Could not encode index ${index} for an unknown reason`)\n            })\n            return encoded + \"]\"\n        "));
        return fn;
    };
    EncoderBuilder.prototype.buildAnyEnocder = function (schema, isChild) {
        if (isChild === void 0) { isChild = false; }
        var validator = (0, getValidator_1.default)(schema, this.validator.builder);
        return new Function(schema.id, "\n            ".concat(!isChild ? (0, extractSourceFromFn_1.default)(validator).replaceAll("return true", "") : "", "\n            return JSON.stringify(").concat(schema.id, ")\n        "));
    };
    EncoderBuilder.prototype.buildEncoder = function (schema, isChild) {
        if (isChild === void 0) { isChild = false; }
        switch (schema.type) {
            case "string":
                return this.buildStringEncoder(schema, isChild);
            case "number":
                return this.buildNumberEncoder(schema, isChild);
            case "boolean":
                return this.buildBooleanEncoder(schema, isChild);
            case "object":
                return this.buildObjectEncoder(schema, isChild);
            case "array":
                return this.buildArrayEncoder(schema, isChild);
            case "any":
                return this.buildAnyEnocder(schema, isChild);
            default:
                throw new Error("No encoder support for type ".concat(schema.type, "}"));
        }
    };
    return EncoderBuilder;
}());
exports.default = EncoderBuilder;
