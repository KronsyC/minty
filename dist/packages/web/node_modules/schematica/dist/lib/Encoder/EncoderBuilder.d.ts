import { BooleanSchema } from '../../Schemas/_BooleanSchema';
import { GenericSchema } from '../../Schemas/Schema';
import { AnySchema, ArraySchema, NumberSchema, ObjectSchema, StringSchema, Validator } from "../..";
export declare const codeGenDeps = "\nfunction $escaped(char){\n    switch(char){\n        case '\"':\n            return '\\\"'\n        case \"\\b\":\n            return \"\\b\"\n        case \"\\\\\":\n            return \"\\\\\\\\\"\n        case \"\\f\":\n            return \"\\\\f\"\n        case \"\\n\":\n            return \"\\\\n\"\n        case \"\\r\":\n            return \"\\\\r\"\n        default:\n            throw new Error(`Could not find escaped version for character ${char}`)\n    }\n}\nfunction $encodeStr(string){\n    let data = string\n    let i=data.length-1;\n    while(i>-1){\n        const char = data[i]   \n        if(char==='\"'|| char===\"\\b\" || char===\"\\\\\" || char===\"\\f\" || char===\"\\n\" || char===\"\\r\" ){                        \n            data = data.slice(0, i) + $escaped(char) + data.slice(i+1)\n            i--   \n        }\n        i--\n    }\n    return '\"' + data + '\"'\n}\n";
export interface BuildEncoderOptions {
    asFunction?: boolean;
    child?: boolean;
    additionalPropertyErrors?: boolean;
}
export default class EncoderBuilder {
    private validator;
    constructor(validator: Validator);
    buildStringEncoder(schema: StringSchema): string;
    buildNumberEncoder(schema: NumberSchema): string;
    buildBooleanEncoder(schema: BooleanSchema): string;
    buildObjectEncoder(schema: ObjectSchema): string;
    buildArrayEncoder(schema: ArraySchema): string;
    buildAnyEncoder(schema: AnySchema): string;
    private getEncoderSource;
    private buildDependencies;
    build(schema: GenericSchema, opts?: BuildEncoderOptions): any;
}
