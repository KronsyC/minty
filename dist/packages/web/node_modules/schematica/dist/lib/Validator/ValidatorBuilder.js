"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var Schemas_1 = require("../../Schemas");
var deps = "\nfunction $stringCheck(data){\n    return typeof data === \"string\"\n}\nfunction $numberCheck(data){\n    return typeof data === \"number\" && isFinite(data) && !isNaN(data)\n}\nfunction $booleanCheck(data){\n    return typeof data === \"boolean\"\n}\nfunction $arrayCheck(data){\n    return Array.isArray(data)\n}\nfunction $objectCheck(data){\n    return typeof data === \"object\" && !Array.isArray(data)\n}\nfunction $anyCheck(data){\n    return !!data\n}\n";
var ValidatorBuilder = (function () {
    function ValidatorBuilder() {
    }
    ValidatorBuilder.prototype.buildStringValidator = function (schema) {
        var varname = schema.id;
        var fn = "\n        if(!$stringCheck(".concat(varname, ")){\n            $error({\n                type: \"ERR_TYPE_MISMATCH\",\n                reason: \"must be of type 'string'\"\n            })\n            return false\n        }\n        ").concat(schema.maxLength < Number.MAX_SAFE_INTEGER ? "if(".concat(varname, ".length > ").concat(schema.maxLength, "){\n            $error({\n                type: \"ERR_OUT_OF_RANGE\",\n                reason: \"must not contain more than ").concat(schema.maxLength, " characters\"\n            })\n            return false\n        }") : "", "\n        ").concat(schema.minLength > 0 ? "if(".concat(schema.id, ".length < ").concat(schema.minLength, "){\n            $error({\n                type: \"ERR_OUT_OF_RANGE\",\n                reason: \"must contain at least ").concat(schema.minLength, " characters\"\n            })\n            return false\n        }") : "", "\n        return true;\n    ");
        return fn;
    };
    ValidatorBuilder.prototype.buildNumberValidator = function (schema) {
        var fn = "\n        if(!$numberCheck(".concat(schema.id, ")){\n            if(isNaN(").concat(schema.id, ")){\n                $error({\n                    type: \"ERR_TYPE_MISMATCH\",\n                    reason: \"cannot be NaN\"\n                })\n                return false\n            }\n            $error({\n                type: \"ERR_TYPE_MISMATCH\",\n                reason: \"must be of type 'number'\"\n            })\n            return false\n        }\n        ").concat(schema.max < Number.MAX_SAFE_INTEGER ? "if(".concat(schema.id, ">").concat(schema.max, "){\n            $error({\n                type: \"ERR_OUT_OF_RANGE\",\n                reason: \"must be less than ").concat(schema.max, "\"\n            })\n            return false\n        }") : "", "\n        ").concat(schema.min > Number.MIN_SAFE_INTEGER ? "if(".concat(schema.id, "<").concat(schema.min, "){\n            $error({\n                type: \"ERR_OUT_OF_RANGE\",\n                reason: \"must be greater than than ").concat(schema.min, "\"\n            })\n            return false\n        }") : "", "\n        return true\n        ");
        return fn;
    };
    ValidatorBuilder.prototype.buildBooleanValidator = function (schema) {
        var fn = "\n        if(!$booleanCheck(".concat(schema.id, ")){\n            $error({\n                type: \"ERR_TYPE_MISMATCH\",\n                reason: \"must be of type 'boolean'\"\n            })\n            return false\n        }\n        return true\n        ");
        return fn;
    };
    ValidatorBuilder.prototype.buildAnyValidator = function (schema) {
        var fn = "\n        if(!$anyCheck(".concat(schema.id, ")){\n            $error({\n                type: \"ERR_NOT_NULLABLE\",\n                reason: \"cannot be a null value\"\n            })\n            return false\n        }\n        return true\n        ");
        return fn;
    };
    ValidatorBuilder.prototype.buildObjectValidator = function (schema) {
        var genKeyCheck = function (name) {
            var e_1, _a;
            var code = "";
            try {
                for (var _b = __values(schema.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 1), key = _d[0];
                    code += "".concat(name, " === \"").concat(key, "\"||");
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            code = code.slice(0, -2);
            return code;
        };
        var strictCheck = function () {
            var code = "";
            if (schema.strict) {
                code += "\n                for(let key in ".concat(schema.id, "){\n                    if(!(").concat(genKeyCheck("key"), ")){\n                        $error({\n                            type: \"ERR_UNEXPECTED_PROPERTY\",\n                            reason: `key ${key} is not allowed`\n                        })\n                        return false\n                    }\n                }\n                ");
            }
            return code;
        };
        var childValidators = function () {
            var code = "";
            schema.properties.forEach(function (child, key) {
                var isRequired = schema.required.includes(key);
                if (isRequired) {
                    code += "\n                    if(".concat(schema.id, "[\"").concat(key, "\"] === undefined){\n                        $error({\n                            type: \"ERR_MISSING_PROPERTY\",\n                            reason: \"missing required property '").concat(key, "'\"\n                        })\n                        return false;\n                    }\n                    if(!validate_").concat(child.id, "(").concat(schema.id, "[\"").concat(key, "\"]))return false;\n                    ");
                }
                else {
                    code += "\n                    if(".concat(schema.id, "[\"").concat(key, "\"]){\n                        if(!validate_").concat(child.id, "(").concat(schema.id, "[\"").concat(key, "\"]))return false;\n                    }\n                    ");
                }
            });
            return code;
        };
        var fn = "\n        if(!$objectCheck(".concat(schema.id, ")){\n            $error({\n                type: \"ERR_TYPE_MISMATCH\",\n                reason: \"must be of type 'object'\"\n            })\n            return false\n        }\n        ").concat(childValidators(), "\n        ").concat(schema.strict ? strictCheck() : undefined, "\n\n        return true\n        ");
        return fn;
    };
    ValidatorBuilder.prototype.buildArrayValidator = function (schema) {
        var childValidators = function () {
            var e_2, _a;
            var code = "";
            try {
                for (var _b = __values(schema.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sch = _c.value;
                    code += "\n                if(validate_".concat(sch.id, "(").concat(schema.id, "[index])){\n                    continue;\n                }\n                ");
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return code;
        };
        var fn = "\n\n            if(!$arrayCheck(".concat(schema.id, ")){\n                throw new Error(`Data must be of type \"array\", but was found to be of type ${typeof ").concat(schema.id, "}`);\n            }\n            ").concat(schema.maxSize < Number.MAX_SAFE_INTEGER ? "if(".concat(schema.id, ".length > ").concat(schema.maxSize, "){\n                throw new Error(`Data may not contain over ").concat(schema.maxSize, " item(s), but was found to have ${").concat(schema.id, ".length}`);\n    \n            }") : "", "\n            ").concat(schema.minSize > 0 ? "if(".concat(schema.id, ".length < ").concat(schema.minSize, "){\n                throw new Error(`Data must contain at least ").concat(schema.minSize, " item(s), but was found to have ${").concat(schema.id, ".length}`);\n            }") : "", "\n            for(let index = 0;index<").concat(schema.id, ".length;index++){\n                ").concat(childValidators(), "\n\n                throw $additionalPropertyError(`Data does not match schema at index ${index}`)\n            }\n            \n            return true\n\n\n        ");
        return fn;
    };
    ValidatorBuilder.prototype.buildDependencies = function (schema) {
        var dependencies = "\n        function $error(params){\n            const {type=\"Validation Error\", reason} = params\n        \n            if(!(type&&reason)){\n                throw (new Error(\"[INTERNAL] Must provide error type, context, and reason\") .name = \"ImplementationError\")\n            }\n            validate_".concat(schema.id, ".error = {\n                type,\n                context: {{name}},\n                reason\n            }\n        }\n        ");
        var types = [];
        if (schema instanceof Schemas_1.ArraySchema || schema instanceof Schemas_1.ObjectSchema) {
            types.push.apply(types, __spreadArray([], __read(schema.allTypes), false));
        }
        types.includes(schema.type) ? undefined : types.push(schema.type);
        dependencies += deps;
        if (schema instanceof Schemas_1.ObjectSchema || schema instanceof Schemas_1.ArraySchema) {
            var children = schema.allChildren;
            for (var path in children) {
                var child = children[path];
                var validator = this.build(child, {
                    isChild: true,
                    context: schema.name + "." + path,
                    asFunction: false
                });
                dependencies += "\n                function validate_".concat(child.id, "(").concat(child.id, "){\n                    \n                // Declare a localized error function bound to the current context\n                function $error(params){\n                    const {type=\"Validation Error\", reason} = params\n\n                    if(!(type&&reason)){\n                        throw (new Error(\"[INTERNAL] Must provide error type, context, and reason\") .name = \"ImplementationError\")\n                    }\n                    validate_").concat(schema.id, ".error = {\n                        type,\n                        context: \"").concat(schema.name + "." + path, "\",\n                        reason\n                    }\n                }\n                    ").concat(validator, "\n                }\n                ");
            }
        }
        return dependencies;
    };
    ValidatorBuilder.prototype.build = function (schema, options) {
        var _a;
        if (options === void 0) { options = {}; }
        var validatorSrc = "";
        if (schema.nullable) {
            validatorSrc += "\n            if(".concat(schema.id, "===undefined||").concat(schema.id, "===null||").concat(schema.id, "===\"\"||").concat(schema.id, "===NaN){\n                return true\n            }\n            ");
        }
        switch (schema.type) {
            case "string":
                validatorSrc += this.buildStringValidator(schema);
                break;
            case "number":
                validatorSrc += this.buildNumberValidator(schema);
                break;
            case "boolean":
                validatorSrc += this.buildBooleanValidator(schema);
                break;
            case "any":
                validatorSrc += this.buildAnyValidator(schema);
                break;
            case "object":
                validatorSrc += this.buildObjectValidator(schema);
                break;
            case "array":
                validatorSrc += this.buildArrayValidator(schema);
                break;
            default:
                throw new Error("Cannot build validator for type ".concat(schema.type));
        }
        var child = (_a = options.isChild) !== null && _a !== void 0 ? _a : false;
        var context = options.context;
        var name = context || schema.name;
        if (!child) {
            var dependencies = this.buildDependencies(schema);
            validatorSrc = dependencies + "\n\n" + validatorSrc;
        }
        validatorSrc = validatorSrc.replaceAll("{{name}}", "\"".concat(name, "\""));
        var asFunction = options.asFunction === undefined ? true : options.asFunction;
        var validator;
        if (asFunction) {
            validator = new Function("\n            let validate_".concat(schema.id, " = function(").concat(schema.id, "){\n                ").concat(validatorSrc, "\n\n            }\n            validate_").concat(schema.id, " = validate_").concat(schema.id, ".bind(validate_").concat(schema.id, ")\n            return validate_").concat(schema.id, "\n            "));
            validator = validator();
            Object.defineProperty(validator, "error", { value: undefined, writable: true, configurable: true });
        }
        else {
            validator = validatorSrc;
        }
        schema.cache.set("validator".concat(options.asFunction === false ? "-asText" : ""), validator);
        return validator;
    };
    return ValidatorBuilder;
}());
exports.default = ValidatorBuilder;
